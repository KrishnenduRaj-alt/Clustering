# -*- coding: utf-8 -*-
"""BisectingKMeans.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/112QiKYM50UtKwb51f9UO_1ji_GgKnnOb
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def load_dataset(file_name="dataset"):
    """
    Loads the dataset from a file and extracts the numerical data, skipping the first column.This function reads the dataset from a file, skips the first column (assumed to be labels),
    and returns the remaining numerical data as a NumPy array.

    Argument is the name of the dataset file (default is "dataset").

    Returns the numerical data extracted from the file [np.ndarray].

    """
    try:
        data_frame = pd.read_csv(file_name, header=None, delim_whitespace=True)
        numeric_data = data_frame.iloc[:, 1:].astype(float)
        return numeric_data.to_numpy()
    except Exception as e:
        print(f"Error reading dataset: {e}")
        exit(1)

def ComputeDistance(point_a, point_b):
    """
    Computes the Euclidean distance between two points. This function calculates the Euclidean distance between two given points in a multidimensional space.

    Args include:
     1. Coordinates of the first point [point_a (numpy.ndarray)].
     2. Coordinates of the second point [point_b (numpy.ndarray)].

    Returns the Euclidean distance between the two points [float]
    """
    return np.linalg.norm(point_a - point_b)

def initialSelection(data_points, num_clusters):
    """
    Selects initial centroids for K-Means++ clustering.This function selects num_clusters initial centroids using the K-Means++ algorithm. It starts by randomly choosing one
    centroid and then iteratively selects the rest of the centroids based on the distances from the existing centroids.

    Args include:
     1.The dataset [data_points (numpy.ndarray)].
     2.The number of clusters [num_clusters (int)].

    Returns the selected initial centroids [np.ndarray]
    """
    np.random.seed(42)
    centroids = [data_points[np.random.choice(len(data_points))]]
    for _ in range(1, num_clusters):
        distances = np.array([min([ComputeDistance(point, centroid) for centroid in centroids]) for point in data_points])
        probabilities = distances * 2 / np.sum(distances * 2)
        next_centroid = data_points[np.random.choice(len(data_points), p=probabilities)]
        centroids.append(next_centroid)
    return np.array(centroids)

def assignClusterIds(data_points, centroids):
    """
    Assigns each data point to the closest centroid. This function assigns each data point in the dataset to the nearest centroid based on Euclidean distance.
    Args include:
     1. The dataset [ data_points (numpy.ndarray)].
     2. The current centroids [centroids (numpy.ndarray)].

    Returns an array of cluster labels for each data point.
    """
    return np.array([np.argmin([ComputeDistance(point, centroid) for centroid in centroids]) for point in data_points])

def computeClusterRepresentatives(data_points, cluster_labels, num_clusters):
    """
    Updates centroids by calculating the mean of all points assigned to each cluster.This function computes new centroids by calculating the mean of all data points assigned to each cluster.
    If a cluster has no points assigned, it selects a random point as the new centroid.

    Args include:
     1. The dataset [data_points (numpy.ndarray)].
     2. The current cluster labels for each data point [cluster_labels (numpy.ndarray)].
     3. The number of clusters [num_clusters (int)].

    Returns the updated centroids for each cluster [np.ndarray ].
    """
    new_centroids = np.zeros((num_clusters, data_points.shape[1]))
    cluster_labels = np.array(cluster_labels)
    for i in range(num_clusters):
        cluster_points = data_points[cluster_labels == i]
        if cluster_points.shape[0] > 0:
            new_centroids[i] = np.mean(cluster_points, axis=0)
        else:
            new_centroids[i] = data_points[np.random.choice(len(data_points))]
    return new_centroids

def k_means_clustering(data_points, num_clusters, max_iters=100, tol=1e-4):
    """
    Implements the K-Means++ clustering algorithm. This function performs K-Means++ clustering. It initializes centroids using K-Means++ and
    iteratively updates the centroids and assigns points to the nearest cluster. It stops when the centroids no longer
    change significantly or the maximum number of iterations is reached.

    Args include:
    1. The dataset [data_points (numpy.ndarray)].
    2. The number of clusters [num_clusters (int)].
    3. The maximum number of iterations for convergence (default is 100) [max_iters (int)].
    4. The tolerance for centroid movement (default is 1e-4) [tol (float)].

    Retuens the final centroids and cluster labels for each data point.
    """
    centroids = initialSelection(data_points, num_clusters)
    for _ in range(max_iters):
        cluster_labels = assignClusterIds(data_points, centroids)
        new_centroids = computeClusterRepresentatives(data_points, cluster_labels, num_clusters)
        if np.linalg.norm(new_centroids - centroids) < tol:
            break
        centroids = new_centroids
    return centroids, cluster_labels

def computeSilhoutteCoefficient(data_points, cluster_labels, num_clusters):
    """
    Computes the average Silhouette coefficient for all points in the dataset. This function computes the Silhouette coefficient for each data point, which measures how well each
    point is assigned to its cluster. The final score is the average of the individual Silhouette coefficients.

    Args include:
      1. The dataset data_points [(numpy.ndarray)].
      2. The cluster labels for each data point [cluster_labels (numpy.ndarray)].
      3. The number of clusters [num_clusters (int)].

    Returns the average Silhouette score for the clustering.
    """
    if num_clusters == 1:
        return 0

    scores = []
    cluster_labels = np.array(cluster_labels)
    for i in range(len(data_points)):
        same_cluster = data_points[cluster_labels == cluster_labels[i]]
        other_clusters = [data_points[cluster_labels == j] for j in range(num_clusters) if j != cluster_labels[i] and data_points[cluster_labels == j].shape[0] > 0]

        if same_cluster.shape[0] > 1:
            a = np.mean([ComputeDistance(data_points[i], p) for p in same_cluster if not np.array_equal(p, data_points[i])])
        else:
            a = 0

        if other_clusters:
            b = np.min([np.mean([ComputeDistance(data_points[i], p) for p in cluster]) for cluster in other_clusters])
        else:
            b = 0

        scores.append((b - a) / max(a, b) if max(a, b) > 0 else 0)

    return np.mean(scores)

def computeSumfSquare(data_points, cluster_labels, centroids):
    """
    Computes the sum of squared distances for each cluster. This function calculates the sum of squared distances between each data point and the corresponding centroid.
    This metric helps evaluate the compactness of the clusters.

    Args include:
      1. data_points - the dataset (np.ndarray).
      2. cluster_labels - the cluster labels for each data point (np.ndarray).
      3. centroids - the centroids of the clusters (np.ndarray).

    Returns the sum of squared distances between points and centroids (float).
    """
    sum_of_squares = 0
    for i in range(len(data_points)):
        sum_of_squares += ComputeDistance(data_points[i], centroids[cluster_labels[i]]) ** 2
    return sum_of_squares

def bisecting_kmeans(data_points, max_clusters=9):
    """
    Bisecting K-Means algorithm to generate hierarchical clusterings. This function performs Bisecting K-Means, which starts with one cluster and splits the data
    recursively into two clusters at each step until the desired number of clusters is reached.

    Args include:
     1. data_points - the dataset (np.ndarray).
     2. max_clusters (int) - the maximum number of clusters to generate (default is 9).

    Returns a numpy.ndarray - the cluster labels for each data point.
    """
    clusters = [data_points]
    cluster_labels = np.zeros(len(data_points), dtype=int)

    for _ in range(1, max_clusters):
        cluster_to_bisect = max(range(len(clusters)), key=lambda i: len(clusters[i]))
        cluster_data = clusters[cluster_to_bisect]

        centroids, labels = k_means_clustering(cluster_data, 2)

        clusters[cluster_to_bisect] = cluster_data[labels == 0]
        clusters.append(cluster_data[labels == 1])

        new_labels = np.zeros(len(data_points), dtype=int)
        for i, cluster in enumerate(clusters):
            new_labels[np.isin(data_points, cluster).all(axis=1)] = i
        cluster_labels = new_labels

    return cluster_labels

def clustername(data_points, num_clusters):
    """
    Perform K-Means clustering and return the cluster assignments.This function applies the K-Means clustering algorithm to the dataset data_points with num_clusters clusters
        and returns the cluster assignments for each data point.

    Args inlcude:
        1. A NumPy array of data points [np.ndarray].
        2. Number of clusters.

    Returns a NumPy array of cluster assignments for each data point.

    """
    _, cluster_ids = k_means_clustering(data_points, num_clusters)
    return cluster_ids

def plot_silhouttee(data_points):
    """
    Calculates and plots the Silhouette coefficient for each num_clusters from 1 to 9 using Bisecting K-Means.
    This function calculates the Silhouette coefficient for Bisecting K-Means clustering for
    different numbers of clusters (1 to 9) and plots the results to visualize the best number of clusters.
    Args include data_points (numpy.ndarray) - the dataset.
    Returns None (this function generates and displays a plot).

    """
    silhouette_values = []

    for num_clusters in range(1, 10):
        cluster_labels = bisecting_kmeans(data_points, max_clusters=num_clusters)
        score = computeSilhoutteCoefficient(data_points, cluster_labels, num_clusters)
        silhouette_values.append(score)

    plt.figure(figsize=(8, 5))
    plt.plot(range(1, 10), silhouette_values, marker='o', linestyle='-', color='b')
    plt.xlabel("Number of Clusters (num_clusters)")
    plt.ylabel("Silhouette Coefficient")
    plt.title("Silhouette Coefficient vs. Number of Clusters [Bisecting K-Means]")
    plt.grid(True)
    plt.savefig("bisecting_silhouette_plot.png")
    plt.show()

if __name__ == "__main__":
    data_points = load_dataset("dataset")
    plot_silhouttee(data_points)